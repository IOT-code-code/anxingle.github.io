---
layout: post
title: 使用神经网络识别手写体数字
category: 计算机
tags: 神经网络
keywords: 
description: 
---

人类视觉系统简直就是一个世界奇迹。看一下接下来的手写体数字序列：     
<center>

![enter description here][1]     
</center>
大部分人都能很容易认出这些数字是：504192。你可能觉得这很不靠谱。在我们每个人的大脑中，都有一个初级视觉皮层，也被称为V1。它包含140*10^6个神经元，而这些神经元之间又有百亿种连接。实际上人类视觉活动不是仅仅只有一个V1层，而是由一系列的视觉皮层-V2，V3，V4和V5。这些视觉皮层在逐层地做更复杂的图像处理工作。我们的大脑好比一个超级计算机，通过成千上万年的进化在逐渐地调整参数，来逐渐理解这个可视化的世界。识别手写体数字不是那么容易。我们人类能够很神奇地理解我们的眼睛呈现给我们的，但是基本上这些工作都是在无意识中完成的。当然了，我们通常根本不了解我们的视觉系统在解决多么困难的问题。    


如果你想写特定程序来识别上面的这种手写体数字，这会非常困难。而视觉模式识别的困难就像这个例子中的一样。我们自己来识别的时候相当容易，但是在计算机视觉中这却变得异常困难。简单的主观经验告诉我们是如何来识别形状的：“9 有一个圈在上边，一条竖线在右下方”。这在算法上很不容易来表达清楚。你试着来将这些规则（识别手写体数字）精确化的时候，肯定就掉坑里了：不是这里有异常就是那里错误了，还有很多的例外情况---这基本上不太可能。      

神经网络用完全不同的方法来解决这个问题。它拿很多的手写体数字（被称为训练集），     
<center>     

![training examples][2]     
</center>
之后从这些训练集中学习。换句话说，神经网络使用训练样本来推测规则，进而识别手写体数字。通过增加训练集的数量，神经网络便能够学习到更多关于手写体数字的**关系**[?]，在这里我仅使用了一百个例子，也许我们可以通过增加上千个甚至百万千万的训练样本来造一个更好的识别系统。     

在这一章中我们要写一程序实现神经网络，来通过学习识别手写体数字。整个程序只有74行，没有使用什么特别的神经网络库。但这个程序没有人干预的情况下还是能达到96%的识别率。而且，接下来的一章里我们通过改进算法能够将算法识别率提高到99%。实际上，最好的商业化神经网络已经被用在银行处理支票以及邮政部门识别地址上了。    

我们关注手写体识别是因为一般来说它是学习神经网路的非常好的原型问题：极具挑战性；能够识别手写体数字可是不小的成就奥---而且并不要求非常复杂的解决方案或者巨大的计算量。进一步来说，这也是发展更先进技术（比如deepLearning）的好方法。所以本书中我们会不断的返回手写体识别这个问题来进行研究。本书后面，我们会讨论如何将这些思想应用在其他诸如计算机视觉，语音识别，自然语言处理等领域。    

当然，如果这一节仅仅是在介绍如何写一段程序来识别手写体，那么这一章本可以很短。但实际上沿着这条思路下来，我们会**衍生**（develop？）出很多关于神经网络的关键思想，比如两种不同的神经元（感知机和sigmoid 神经元），以及被广泛熟知的标准神经网络学习算法：随机梯度下降算法。自始至终，我都在极力地解释为什么这样来做，并且一直在给大家建立一种神经网络的直观印象。如果我详细阐释基本的概念，这会需要更多的讨论，但是对于你更深层次的理解这些概念还是很有帮助的！最后在本书的最后一章，我们将会理解深度学习是什么，以及为什么它这么重要。    

## 感知器    
神经网络是什么？开始我将会解释一种被称为感知器的人工神经元。神经元这一概念最早是由[Frank Rosenblatt](https://en.wikipedia.org/wiki/Frank_Rosenblatt)于1950s到1960s受[Warren McCulloch](https://en.wikipedia.org/wiki/Warren_McCulloch)和[Walter Pitts](https://en.wikipedia.org/wiki/Walter_Pitts)的[研究](http://scholar.google.ca/scholar?cluster=4035975255085082870)所启发而提出的。今天，使用其他的人工神经元模型更为普遍---在本书中以及当前人工神经网络的研究中主要被使用的神经元模型被称为 sigmoid神经元。我们也将会简单讲解 sigmoid 神经元。但为了明白为什么sigmoid 神经元如此定义，还是有必要首先去花些时间来理解感知器。    

那么感知器是如何工作的呢？一个感知器接收若干**二进制**（binary?）输入,      

<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>x</mi>
    <mn>1</mn>
  </msub>
  <mo>,</mo>
  <msub>
    <mi>x</mi>
    <mn>2</mn>
  </msub>
  <mo>,</mo>
</math>,...,然后产生一个二进制输出：
<center>    

![enter description here][3]
</center>
这个例子中的感知器有三个输入,<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>x</mi>
    <mn>1</mn>
  </msub>
  <mo>,</mo>
  <msub>
    <mi>x</mi>
    <mn>2</mn>
  </msub>
  <mo>,</mo>
  <msub>
    <mi>x</mi>
    <mn>3</mn>
  </msub>
</math>。一般来说它可以有更多或者更少的输入。Rosenblatt提出了一种简单的规则来计算输出---权重：<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>w</mi>
    <mn>1</mn>
  </msub>
  <mo>,</mo>
  <msub>
    <mi>w</mi>
    <mn>2</mn>
  </msub>
  <mo>,</mo>
  <mo>&#x2026;<!-- … --></mo>
</math>用这些实数来表示各自对应的输入关于输出的**重要性**（importance?）。

  [1]: ./images/00.png "00.png"
  [2]: ./images/01.png "01.png"
  [3]: ./images/02.png "02.png"